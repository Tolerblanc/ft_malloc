```c
#include <unistd.h>

int getpagesize(void);

#include <sys/resource.h>

int getrlimit(int resource, struct rlimit *rlp);
```

getpagesize() 함수는 페이지의 바이트 수를 반환합니다.  페이지 단위는 많은 메모리 관리 호출의 단위입니다.

페이지 크기는 시스템 페이지 크기이며 기본 하드웨어 페이지 크기와 동일하지 않을 수 있습니다.

현재 프로세스 및 해당 프로세스가 생성하는 각 프로세스의 시스템 리소스 사용량 제한은 getrlimit() 호출로 구할 수 있으며, setrlimit() 호출로 설정할 수 있습니다.

리소스 매개변수는 다음 중 하나입니다:

    RLIMIT_CORE     생성할 수 있는 최대 크기(바이트)의 코어 파일입니다.

    RLIMIT_CPU      각 프로세스에서 사용할 수 있는 최대 CPU 시간(초)입니다.

    RLIMIT_DATA     프로세스에 대한 데이터 세그먼트의 최대 크기(바이트)로, 프로그램이 sbrk(2) 시스템 콜을 통해 중단을 확장할 수 있는 범위를 정의합니다.

    RLIMIT_FSIZE    생성할 수 있는 최대 크기(바이트) 파일.

    RLIMIT_MEMLOCK  프로세스가 mlock(2) 함수를 사용하여 메모리에 잠글 수 있는 최대 크기(바이트)입니다.

    RLIMIT_NOFILE   이 프로세스의 최대 열린 파일 수 입니다.

    RLIMIT_FSIZE    생성할 수 있는 최대 크기(바이트) 파일.

    RLIMIT_MEMLOCK  프로세스가 mlock(2) 함수를 사용하여 메모리에 잠글 수 있는 최대 크기(바이트)입니다.

    RLIMIT_NOFILE   이 프로세스의 최대 열린 파일 수입니다.

    RLIMIT_ NPROC   이 사용자 아이디에 대한 최대 동시 프로세스 수입니다.

    RLIMIT_RSS      프로세스의 상주 집합 크기가 커질 수 있는 최대 크기(바이트)입니다. 
                    이는 프로세스에 할당할 수 있는 물리적 메모리 양에 제한을 두며, 메모리가 부족할 경우 시스템은 선언된 상주 세트 크기를 초과하는 프로세스에서 메모리를 가져오는 것을 선호합니다.

    RLIMIT_STACK    프로세스에 대한 스택 세그먼트의 최대 크기(바이트)로, 프로그램의 스택 세그먼트가 확장될 수 있는 범위를 정의합니다. 스택 확장은 시스템에 의해 자동으로 수행됩니다.

리소스 제한은 소프트 제한과 하드 제한으로 지정됩니다.  
소프트 제한을 초과하면 프로세스가 신호를 받을 수 있지만(예: CPU 시간 또는 파일 크기 초과), 하드 제한에 도달하거나 리소스 제한을 수정할 때까지 실행을 계속할 수 있습니다.
리소스에 대한 하드 및 소프트 한도를 지정하는 데는 `rlimit` 구조체가 사용됩니다,

```c
struct rlimit {
        rlim_t  rlim_cur;       /* current (soft) limit */
        rlim_t  rlim_max;       /* hard limit */
};
```

수퍼유저만 최대 한도를 올릴 수 있습니다. 
다른 사용자는 `rlim_cur`를 0에서 `rlim_max` 범위 내에서만 변경하거나 `rlim_max`를 (비가역적으로) 낮출 수 있습니다.

이 정보는 프로세스별 정보에 저장되기 때문에 셸이 생성하는 모든 향후 프로세스에 영향을 미치려면 이 시스템 호출을 셸에서 직접 실행해야 합니다. 따라서 limit은 csh(1)에 내장된 명령이고 ulimit은 sh(1)에 해당하는 명령입니다.

시스템은 정상적인 방법으로 제한을 초과할 경우 데이터 또는 스택 공간 확장을 거부합니다. 데이터 공간 제한에 도달하면 중단 호출이 실패합니다.
스택 제한에 도달하면 프로세스는 세분화 오류(SIGSEGV)를 수신하며, 신호 스택을 사용하는 처리기가 이 신호를 포착하지 못하면 이 신호가 프로세스를 종료합니다.

프로세스의 소프트 제한보다 큰 파일을 생성하는 파일 I/O 작업으로 인해 쓰기가 실패하고 SIGXFSZ 신호가 생성되면 일반적으로 프로세스가 종료되지만 이 신호가 포착될 수도 있습니다.  
소프트 CPU 시간 제한이 초과되면 문제가 되는 프로세스에 SIGXCPU 신호가 전송됩니다.

다음과 같은 경우 getrlimit() 및 setrlimit() 시스템 호출이 실패합니다:

     [EFAULT] rlp에 지정된 주소가 유효하지 않습니다.

     [EINVAL] 리소스가 유효하지 않습니다.